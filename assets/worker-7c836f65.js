(function(){"use strict";console.log("worker_v0.1.2-alpha");class m{constructor(e,t){this.order_book=this.initialize_order_book(e,t)}initialize_order_book(e,t){let s=e.map(n=>n.map(Number)),r=t.map(n=>n.map(Number));return{bids:s,asks:r}}async refresh_order_book(e){g=e;let t=new AbortController,s=setInterval(async()=>{if(!u||e!==g)clearInterval(s),t.abort();else{t=new AbortController;try{let r=await b(e,{signal:t.signal});this.order_book=this.initialize_order_book(r.bids,r.asks)}catch(r){r.name==="AbortError"?console.log("Fetch operation aborted"):console.error("Error fetching order book:",r)}}},6e3)}async update_order_book(e,t){let s=e.map(n=>n.map(Number)),r=t.map(n=>n.map(Number));[this.order_book.bids,this.order_book.asks]=await this.prepare_order_book(this.order_book.bids,this.order_book.asks,s,r)}async prepare_order_book(e,t,s,r){const n=new Map([...e,...s].filter(a=>a[0]>=e[e.length-1][0])),E=new Map([...t,...r].filter(a=>a[0]<=t[t.length-1][0]));return e=Array.from(n.entries()).filter(a=>a[1]!==0).sort((a,k)=>k[0]-a[0]),t=Array.from(E.entries()).filter(a=>a[1]!==0).sort((a,k)=>a[0]-k[0]),[e,t]}}let i,p=[],g,l,f=!0,u=!0,c,d;self.onmessage=o=>{o.data.type==="createWebSocket"&&h(o.data.symbol),o.data.type==="terminateWebsocket"&&(console.log("worker.js: Terminating websocket connection..."),i.close(),v())};function h(o){i&&i.readyState===1&&(console.log("worker.js: Closing existing websocket connection for symbol:",l.toUpperCase()),i.close(),self.postMessage({type:0}),f=!0,d=null,p=[]),console.log("worker.js: Creating websocket connection for symbol:",o),l=o.toLowerCase(),b(l).then(e=>{i=new WebSocket(`wss://fstream.binance.com/stream?streams=${l}@aggTrade/${l}@depth@100ms`),w(i),c=e.lastUpdateId,d=new m(e.bids,e.asks)}).catch(e=>{console.error("Error initializing the order book:",e)})}function w(o){o.addEventListener("open",()=>{d.refresh_order_book(l),self.postMessage({type:1})}),o.addEventListener("close",()=>{console.log("worker.js: WebSocket connection closed")});let e=!1;o.addEventListener("message",async t=>{let s=JSON.parse(t.data);if(s.stream.endsWith("@aggTrade")){let r=s.data;p.push({x:r.T,y:parseFloat(r.p),r:parseFloat(r.q),m:r.m})}else if(s.stream.endsWith("@depth@100ms")){if(e){console.log("isHandlingDepth:",e);return}e=!0,await y(s.data),e=!1}})}async function y(o){let e=o.u,t=o.U,s=o.pu;if(!(e<c)){if(f)if(t<=c&&c<=e)console.log("First processed event succeed."),f=!1;else{await _();return}else if(s!=c){await _();return}await d.update_order_book(o.b,o.a),c=e,self.postMessage({type:"u",depth:d.order_book,tradesBuffer:p,update_time:o.E}),p=[]}}async function _(){console.log("Out of sync, reinitializing order book...");const o=await b(l);c=o.lastUpdateId,d.order_book=d.initialize_order_book(o.bids,o.asks),p=[]}async function b(o){return await(await fetch(`https://fapi.binance.com/fapi/v1/depth?symbol=${o}&limit=500`)).json()}function v(){i?(i.close(),u=!1,self.postMessage({type:"x",message:"OK"})):(console.log("worker.js: No websocket connection to terminate."),self.postMessage({type:"x",message:"ERR: No websocket connection to terminate."}))}})();
